/* shmp1.cpp */

/*
import necessary libraries
*/
#include "registration.h"
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <iostream>
#include <stdio.h>
#include <memory.h>
#include <semaphore.h> // POSIX implementation of semaphore 
#include <fcntl.h> //  for O_* constants in sem_open()
#include <pthread.h>

using namespace std;

/*
class_number = 1001
date = 120119
title = Operating Systems
seats_left = 15
*/
CLASS myclass = { "1001", "120119", "Operating Systems", 15 };

/*
Tells preprocessor to set all occurences of the identifier "NCHILD" in the program to 3
*/
#define NCHILD	3

/*
Declare methods
*/
int	shm_init( void * );
void	wait_and_wrap_up( int [], void *, int, sem_t *);
void	rpterror( char *, char * );

int main(int argc, char *argv[])
{
	/*
	declare variables
	*/
	int 	child[NCHILD], i, shmid;
	void	*shm_ptr;
	char	ascshmid[10], pname[14];

	// semaphore pointer
	sem_t *sem_ptr;


	/* 
	invoke shm_init() passing in the smh_ptr
	set the return value to shmid
	*/
	shmid = shm_init(shm_ptr);

	/*
	store contents of "shmid" in the format specified to 
	buffer pointed to by "ascshmid" as a C-String 
	*/
    sprintf (ascshmid, "%d", shmid);

	/* 
	init named semaphore "shmSem"
	O_CREAT to create new semaphore
	0644 gives owner read and write privileges, everyone else has read only permission
	1 indicates initial value of semaphore
	*/
	sem_ptr = sem_open("shmSem", O_CREAT, 0644, 1);

	/*
	Loop and fork() NCHILD times
	*/
	for (i = 0; i < NCHILD; i++) {
		/*
		store each child process in child queue
		*/
		child[i] = fork();

		// check if fork successful
		switch (child[i]) {
		case -1:
			// unsuccessful fork invokes rpterror function
			rpterror ("fork failure", pname);
			exit(1);
		case 0:
			/* 
			successful fork. child i is stored into buffered pointed to by "pname" in specified format
			execute shmc1 program, passing in the child, shmid
			perror if execl failed
			*/
			sprintf (pname, "shmc%d", i+1);

			// execute child process, passing in the filename, pname, ascshmid, named semaphore, and 0 to indicate end of char array.
			execl("shmc1", pname, ascshmid, "shmSem", (char *)0);
			perror ("execl failed");
			exit (2);
		}
	}
	
	/*
	parent process invokes wait_and_wrap_up, passing in the child process, shm_ptr, and shmid
	pass in semaphore
	*/
	wait_and_wrap_up (child, shm_ptr, shmid, sem_ptr);
	return 0;
}

/*
defines the function shm_init
*/
int shm_init(void *shm_ptr)
{
	// initialize shmid
	int	shmid;

	/*
	shmget allocates a System V shared memory segment
	Returns the ID of the segment with the key generated by ftok
	sets the size to previously defined CLASS structure
	sets permission to 0600
	IPC_CREAT flag used to create a new instance of the shared memory segment
	*/
	shmid = shmget(ftok(".",'u'), sizeof(CLASS), 0600 | IPC_CREAT);

	// failed
	if (shmid == -1) {
		perror ("shmget failed");
		exit(3);
	}

	/*
	attaches the shared memory segment identified by shmid to the address space of the calling process
	returns the address of the attached shared memory segment and assigns it to shm_ptr
	*/
	shm_ptr = shmat(shmid, (void * ) 0, 0);
	
	// failed
	if (shm_ptr == (void *) -1) {
		perror ("shmat failed");
		exit(4);
	}
	
	/*
	Copies n bytes of memory area "myclass" to memory area "shm_ptr" with the size "CLASS"
	*/
	memcpy (shm_ptr, (void *) &myclass, sizeof(CLASS) );

	return (shmid);
}

// defines the function wait_and_wrap_up
void wait_and_wrap_up(int child[], void *shm_ptr, int shmid, sem_t *sem_ptr)
{
	// initialize variables and set to NCHILD
	int wait_rtn, w, ch_active = NCHILD;

	/*
	loop while there are active children processes
	*/
	while (ch_active > 0) {
		
		/*
		parent process waits for child process to terminate. 
		assigns ID of the terminated child to wait_rtn
		loop through each child process in the child queue until the ID matches the child and decrement ch_active
		*/
		wait_rtn = wait( (int *)0 );
		for (w = 0; w < NCHILD; w++)
			if (child[w] == wait_rtn) {
				ch_active--;
				break;
			}
	}


	cout << "Parent removing shm" << endl;
	cout << "Parent removing semaphore" << endl;

	/*
	detaches the shared mem segment located at address pointed to by shm_ptr
	*/
	shmdt (shm_ptr);

	/*
	system call to mark the shared memory segment to be destroyed. 
	the caller must be the creator of the segment
	*/
	shmctl (shmid, IPC_RMID, (struct shmid_ds *) 0);

	// remove and destroy a named semaphore
	sem_unlink("shmSem");
	
	// close the named semaphore pointed to by sem_ptr
	sem_close(sem_ptr);

	exit (0);
}

// defines the function rpterror
void rpterror(char *string, char *pname)
{
	//initialize variables
	char errline[50];

	//store contents of string and pname as C-string to buffer pointed to by errline in the format specified
	sprintf (errline, "%s %s", string, pname);
	//print the error
	perror (errline);
}
